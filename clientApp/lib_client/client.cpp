#include "client.h"
#include <algorithm>
#include <sys/time.h>
#include <iostream>

using namespace std;

/**
* @brief Creates a Client with the specified id.
*
* Starts the client giving an id as parameter.
*
* It calculates the amount of space that is going to be used as a buffer for the server
* messages and allocates enough space for it. After that, it makes the class internal
* pointers, point to the correct positions in this allocated memory.
*
* It also set the families of the sockets
*
* @param client A client identifier
*
* @returns A client network layer
*/
Client::Client(int client, int server)
{
	int i, status;
	socklen_t len;

	last = -1;
	current = -1;

	serverMessageSize = serverBufferSize();
	clientMessageSize = clientBufferSize();
	serverMessageArea = (char *)prepareServerBuffer();
	clientMessageArea = (char *)prepareClientBuffer();

	sHeader = (MessageHeader *) serverMessageArea;
	msgNumber = (unsigned int *) (serverMessageArea + sizeof(MessageHeader));
	players = (int *) (serverMessageArea + sizeof(MessageHeader) + sizeof(int));
	stats = (PrimaryStats *) (serverMessageArea + sizeof(MessageHeader) + (1 + 8)*sizeof(int));
	
	cHeader = (MessageHeader *) clientMessageArea;
	cmsg = (ClientMessage*) (clientMessageArea + sizeof(MessageHeader));

	states = new State[256];
	receivedStatus = new char[256];
	i = 0;
	while(i < 256)
	{
		states[i].players = new int[8];
		states[i].stats = new PrimaryStats[8];
		receivedStatus[i] = 0;
		i++;
	}

	cHeader->senderId = client;
	cHeader->senderType = 'C';
	cHeader->dest = server;

	socketFd = socket(AF_INET, SOCK_DGRAM, 0);
}

/**
* @brief Connects to the server at the specified address and port
*
* Given an IP, this function defines the send address and the receive address, binding
* The second one to receive messages.
*
* The client, sends a message(512) asking for connection from the server which has 2 seconds
* to answer.
*
* After receiving a positive answer. It picks up the correct position of the player in the
* array of active players.
*
* It also sets the timeout on the sockets to 0.1 second.
*
* @param addr The server's ip address
* @param character The character selected to join the server
* @param port The server's port
*
* @returns The number of bytes from the server message or -1 in case of failure
*/
int Client::connect(const char* addr, int character, int port)
{
	int i, status, time;
	struct timeval tv;

	last = 0;
	current = 0;

	sendAddr.sin_family = AF_INET;
	sendAddr.sin_port = htons(7000);
	sendAddr.sin_addr.s_addr = inet_addr(addr);

	recvAddr.sin_family = AF_INET;
	recvAddr.sin_port = htons(port);
	recvAddr.sin_addr.s_addr = inet_addr("0.0.0.0");
	
	status = bind(socketFd, (struct sockaddr *)&recvAddr, sizeof(sockaddr_in));

	tv.tv_sec = 1;
	tv.tv_usec = 0;
	//tv.tv_usec = 200000;
	setsockopt(socketFd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(struct timeval));

	cHeader->msgType = 1;
	cmsg->message = character;
	sendto(socketFd, clientMessageArea, clientMessageSize, 0, (sockaddr*)&sendAddr, sizeof(sockaddr_in));
	status = getPacket();
	i = 0;
	while(status == -1)
	{
		sendto(socketFd, clientMessageArea, clientMessageSize, 0, (sockaddr*)&sendAddr, sizeof(sockaddr_in));
		status = getPacket();
		cout << status << endl;
		i++;
		if(i > 10)
		{
			status = -3;
		}
	}

	tv.tv_sec = 0;
	tv.tv_usec = 1000;
	setsockopt(socketFd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(struct timeval));

	i = 0;
	while(i < 8)
	{
		if(players[i] == cHeader->senderId)
		{
			position = i;
		}
		i++;
	}

	return status;
}

/**
* @brief Recieves a message from the server
*
* Receives a message from the server and send back an ACK
*
* @returns The number of bytes read, -1 in case of general error, or -2 in case the message
* starts with the wrong signature
*/
int Client::getPacket()
{
	int i, server, status, *p, c;
	socklen_t len;
	len = sizeof(sockaddr_in);
	
	status = recvfrom(socketFd, serverMessageArea, serverMessageSize, 0, (sockaddr *)&recvAddr, &len);

	if(status != -1)
	{
		if(sHeader->senderType != 'S')
		{
			return -2;
		}
		else
		{
			status = sHeader->msgType;
		}

		if(sHeader->msgType == 0)
		{
			last = current;
			current = *msgNumber;
			c = 0x000000FF & current;
			if(receivedStatus[c] == 0)
			{
				p = (int *)serverMessageArea;
				server = *p;
				copy(players, players + 8, states[c].players);
				copy(stats, stats + 8, states[c].stats);
				receivedStatus[c] = 1;
//				cout << "message received: " <<  current << endl;

				cmsg->turn = current;
			}
			sendAck();
		}
	}

	return status;
}

/**
* @brief Starts server synchronization
*
* Not implemented yet
*/
int Client::servSynchronize()
{
	int status;
	
	status = 0;

	return status;
}

/**
* @brief send a message to the server
*
* Send a message to the server containing the event happening on the client and the turn.
*
* @param ev Event generated by the client
* @param turn The turn in which the event was generated
*
* @returns the number of bytes sent, or -1 in case of errors
*/
int Client::sendEvent(int ev, int turn)
{
	int status;

	cmsg->message = ev;
	cmsg->turn = turn;
	cHeader->msgType = 0;
	
	status = sendto(socketFd, clientMessageArea, clientMessageSize, 0, (sockaddr*)&sendAddr, sizeof(sockaddr_in));

	return status;
}

/**
* @brief send a string to the server
*
* Sends at most 80 characters to the server, size will be ignored if the string has more than
* 80 chars
*
* @param string The string to be sent
* @param size The size of the string
*
* @returns the number of bytes sent, or -1 in case of errors
*/
int Client::sendString(char* string, int size)
{
	int status, i, asize;
	char *message;

	asize = 83 + sizeof(int);
	message = new char[asize];
	i = 2;
	while(i < 83)
	{
		message[i] = 0;
		i++;
	}
	message[0] = 'C';
	message[1] = 1;
	*(message + 2) = cHeader->senderId;

	if(size > 81)
	{
		size = 81;
	}

	i = 0;
	while(i < size)
	{
		message[i + 2 + sizeof(int)] = string[i];
		i++;
	}
	
	status = sendto(socketFd, message, 83 + sizeof(int), 0, (sockaddr*)&sendAddr, sizeof(sockaddr_in));

	return status;
}

/**
* @brief Deprecated. Get the number of the current state
*
* Returns the number of the current message captured by the client
*
* @returns the number of the current state
*/
int Client::getCurrentStateNumber()
{
	return current;
}

/**
* @brief Deprecated. Get the number of the last state
*
* Returns the number of the last message captured by the client
*
* @returns the number of the last state
*/
int Client::getLastStateNumber()
{
	return last;
}

/**
* @brief Deprecated. Get the current state
*
* Returns the state of the current message captured by the client
*
* @returns The current state
*/
State Client::getCurrentState()
{
	return states[current & 0x000000FF];
}

/**
* @brief Deprecated. Get the last state
*
* Returns the state of the last message captured by the client
*
* @returns The last state
*/
State Client::getLastState()
{
	return states[last & 0x000000FF];
}

/**
* @brief Get the requested state
*
* Returns the requested state and mark it as not received, since the number of states is
* limited, the method must find out where the requested state is or if it was not discarded
*
* @param state The number of the state requested
*
* @returns The requested state
*/
State Client::getState(int state)
{
	int c;

	c = state & 0x000000FF;

	receivedStatus[(state - 1) & 0x000000FF] = 0;
	return states[c];
}

/**
* @brief Checks if the client already received the state requested
*
* Returns an integer signalizing if the state was received or not.
*
* @param state The number of the state requested
*
* @returns 0 if not received, 1 if received
*/
int Client::stateReceived(int state)
{
	return receivedStatus[state & 0x000000FF];
}

/**
* @brief Find this client's position in the array of states
*
* It returns the client's position in the state's array of objects.
* Enables quick access to the client's object info.
*
* @returns The client's position in the array of state
*/
int Client::getClientArrayPosition()
{
	return position;
}

/**
* @brief deprecated
*
* Not sure if using
*/
PrimaryStats* Client::getStats()
{
	return stats;
}

/**
* @brief Sends an Ack to the server
*
* Sends an Acknowledgment package to the server to avoid network flooding. Not really necessary
* Because the server uses the message itself as an ACK. But generates redundancy for the server
* to acknowledge the package receiving.
*/
void Client::sendAck()
{
	cHeader->msgType = 64;
	
	sendto(socketFd, clientMessageArea, clientMessageSize, 0, (sockaddr*)&sendAddr, sizeof(sockaddr_in));
}

int Client::disconnect()
{
	cHeader->msgType = 2;
	
	sendto(socketFd, clientMessageArea, clientMessageSize, 0, (sockaddr*)&sendAddr, sizeof(sockaddr_in));
}
